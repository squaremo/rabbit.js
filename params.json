{"name":"rabbit.js","tagline":"Messaging in Node.JS made easy using RabbitMQ","body":"# Messaging in Node.JS with RabbitMQ\r\n\r\n    $ npm install rabbit.js\r\n\r\nThis library provides a simple, socket-oriented API* for messaging in\r\n[Node.JS](http://nodejs.org/), using\r\n[RabbitMQ](http://www.rabbitmq.com/) as a backend.\r\n\r\n```js\r\nvar context = require('rabbit.js').createContext();\r\ncontext.on('ready', function() {\r\n  var pub = context.socket('PUB'), sub = context.socket('SUB');\r\n  sub.pipe(process.stdout);\r\n  sub.connect('events', function() {\r\n    pub.connect('events', function() {\r\n      pub.write(JSON.stringify({welcome: 'rabbit.js'}), 'utf8');\r\n    });\r\n  });\r\n});\r\n```\r\n\r\n**NB** This README is provisional, in that it follows the master\r\nbranch and may be inaccurate with respect to released versions of\r\nrabbit.js. See NPM for the documentation of the most recent release:\r\nhttps://www.npmjs.org/package/rabbit.js#readme.\r\n\r\n*Yes, rather like ZeroMQ. [See below](#zeromq).\r\n\r\n## Status\r\n\r\nStill on major version `0`, though in use in a number of places, I\r\nbelieve.\r\n\r\nVersion 0.3.0 and on are built on [amqplib][]. Previous versions, of\r\nwhich v0.2.2 was the last, used [node-amqp][].\r\n\r\n## Uses\r\n\r\nThis library is suitable for co-ordinating peers (e.g., Node.JS\r\nprograms), acting as a gateway to other kinds of network (e.g.,\r\nrelaying to browsers via SockJS), and otherwise as a really easy way\r\nto use RabbitMQ.\r\n\r\n## API\r\n\r\nThe entry point is `createContext`, which gives you a factory for\r\nsockets. You supply it the URL to your RabbitMQ server:\r\n\r\n```js\r\nvar context = require('rabbit.js').createContext('amqp://localhost');\r\n```\r\n\r\nThe context will emit `'ready'` when it's connected.\r\n\r\nA context will emit `'error'` with an `Error` object if there's a\r\nproblem with the underlying connection to the server. This invalidates\r\nthe context and all its sockets.\r\n\r\nA context may be disconnected from the server with `#close()`. It will\r\nemit `'close'` once the underlying connection has been terminated, by\r\nyou or by an error.\r\n\r\n### Sockets\r\n\r\nTo start sending or receiving messages you need to acquire a socket:\r\n\r\n```js\r\nvar pub = context.socket('PUBLISH');\r\nvar sub = context.socket('SUBSCRIBE');\r\n```\r\n\r\nand connect it to something:\r\n\r\n```js\r\npub.connect('alerts');\r\nsub.connect('alerts');\r\n```\r\n\r\nSockets are [Streams][nodejs-stream] in object mode, with buffers as\r\nthe objects. In particular, you can `#read()` buffers from those that\r\nare readable (or supply a callback for the `'data'` event, if you are\r\nan adherent of the old ways), and you can `#write()` to those that are\r\nwritable.\r\n\r\nIf you're using strings, you can `setEncoding()` to get strings\r\ninstead of buffers as data, and supply the encoding when writing.\r\n\r\n```js\r\nsub.setEncoding('utf8');\r\nsub.on('data', function(note) { console.log(\"Alarum! %s\", note); });\r\n\r\npub.write(\"Emergency. There's an emergency going on\", 'utf8');\r\n```\r\n\r\nYou can also use `#pipe` to forward messages to or from another\r\nstream, making relaying simple:\r\n\r\n```js\r\nsub.pipe(process.stdout);\r\n```\r\n\r\nA socket may be connected more than once, by calling\r\n`socket.connect(x)` with different `x`s. What this entails depends on\r\nthe socket type (see below). Messages to and from different\r\n`connect()`ions are not distinguished. For example\r\n\r\n```js\r\nvar sub2 = context.socket('SUBSCRIBE');\r\nsub2.connect('system');\r\nsub2.connect('notifications');\r\n```\r\n\r\nHere, the socket `sub2` will receive all messages published to\r\n`'system'` and all those published to `'notifications'` as well, but\r\nit is not possible to distinguish among the sources. If you want to do\r\nthat, use distinct sockets.\r\n\r\n#### `Socket#close` and `Socket#end`\r\n\r\nA socket may be closed using `#close()`; this will clean up resources,\r\nand emit `'close'` once it's done so.\r\n\r\nA writable socket may be closed with a final write by calling\r\n`#end([chunk [, encoding]])`. Given no arguments, `#end` is the same\r\nas `#close`.\r\n\r\n### Socket types\r\n\r\nThe socket type, passed as the first argument to `Context#socket`,\r\ndetermines whether the socket is readable and writable, and what\r\nhappens to buffers written to it. Socket types are used in the pairs\r\ndescribed below.\r\n\r\n**PUBLISH** / **SUBSCRIBE** (also PUB / SUB): every SUB socket\r\nconnected to <x> gets messages sent by a PUB socket connected to <x>;\r\na PUB socket sends every message to each of its connections. SUB\r\nsockets are readable only, and PUB sockets are writable only. The\r\nmessages actually received are determined by the parameters with which\r\nthe SUB socket is connected, and the topic used by the PUB socket --\r\nsee \"Topics\" below.\r\n\r\n**PUSH** / **PULL**: a PUSH socket will send each message to a\r\nsingle connection, using round-robin. A PULL socket will receive a\r\nshare of the messages sent to each <y> to which it is connected,\r\ndetermined by round-robin at <y>. PUSH sockets are writable only, and\r\nPULL sockets are readable only.\r\n\r\n**REQUEST** / **REPLY** (also REQ / REP): a REQ socket sends each\r\nmessage to one of its connections, and receives replies in turn; a REP\r\nsocket receives a share of the messages sent to each <y> to which it\r\nis connected, and must send a reply for each, in the order they come\r\nin. REQ and REP sockets are both readable and writable.\r\n\r\n**PUSH** / **WORKER**: a WORKER socket is similar to a PULL socket,\r\nbut requires that you call `#ack` on it to acknowledge that you have\r\nprocessed each message. Any messages left unacknowledged when the\r\nsocket closes, or crashes, will be requeued and delivered to another\r\nconnected socket (should there be one). A worker socket is read-only,\r\nand has the additional method `#ack` which acknowledges the oldest\r\nunacknowledged message, and must be called once only for each message.\r\n\r\nA way to maintain ordering for REP and WORKER sockets is shown in the\r\n[\"ordering\" example][ordering-example].\r\n\r\n#### Topics and topic patterns\r\n\r\n**PUB** and **SUB** sockets have an extra feature: the messages sent\r\nby a PUB socket are routed to SUB sockets according to a topic given\r\nby the PUB socket, and topic patterns given by the SUB socket.\r\n\r\nA PUB socket may set its `'topic'` using `#setsockopt('topic',\r\nstring)`. All messages sent with `#write` will use that\r\ntopic. Alternatively, you can use `#publish(topic, message,\r\n[encoding])` to give the topic per message.\r\n\r\nA SUB socket may pass in an additional parameter, in the second\r\nposition, to `#connect`. This extra argument is a pattern that is\r\nmatched against message topics; how the matching is done depends on\r\nthe `'routing'` option given to the sockets (they must agree on the\r\nvalue):\r\n\r\n - `'fanout'` is the default and means all messages go to all SUB\r\n   sockets, regardless of the topic or topic pattern.\r\n - `'direct'` means that message topics are matched with patterns\r\n   using string equality.\r\n - `'topic'` uses AMQP's wildcard matching: briefly, a topic consists\r\n   of `'.'`-delimited words, and a pattern is the same but may contain\r\n   wildcards, `'*'` meaning \"any single word\" and `'#'` meaning \"any\r\n   sequence of words\". So, the pattern `\"*.bar.#\"` will match the\r\n   topic `foo.bar.baz.bam\"`. There's a longer explanation in the\r\n   RabbitMQ [tutorial on topic matching][rabbitmq-topic-tute].\r\n\r\nLeaving all the options alone, and using only the two-argument version\r\nof `#connect`, all SUB sockets connected to X will get all messages\r\nsent by PUB sockets connected to X.\r\n\r\n#### Socket options\r\n\r\nSome socket types have options that may be set at any time with\r\n`Socket#setsockopt`, or given a value when the socket is created, in\r\nthe second argument to `Context#socket`.\r\n\r\n##### `routing` and `topic`\r\n\r\n`routing` is supplied to a **PUB** or **SUB** socket on creation, and\r\ndetermines how it will match topics to topic patterns, as described\r\nunder \"Topics\". Sockets connected to the same address must agree on\r\nthe routing.\r\n\r\n`topic` may be set on a **PUB** socket to give the topic for\r\nsubsequent messages sent using `#write`.\r\n\r\n##### `expiration`\r\n\r\nThe option `'expiration'` may be set on writable sockets, i.e., PUB,\r\nPUSH, REQ and REP. It is given as a number of milliseconds:\r\n\r\n```js\r\npub.setsockopt('expiration', 60 * 1000)\r\n```\r\n\r\nIn the example, messages written to `pub` will be discarded by the\r\nserver if they've not been delivered after 60,000\r\nmilliseconds. Message expiration only works with versions of RabbitMQ\r\nnewer than 3.0.0.\r\n\r\nYou need to be careful when using expiry with a **WORKER**, **REQ** or\r\n**REP** socket, since losing a message will break ordering. Only\r\nsending one request at a time, and giving requests a time limit, may\r\nhelp.\r\n\r\n##### `prefetch`\r\n\r\nThe option `'prefetch'`, determines how many messages RabbitMQ will\r\nsend to the socket before waiting for some to be processed. This only\r\nhas a noticable effect for **WORKER** and **REP** sockets. It is best\r\nset when the socket is created, but may be set any time afterwards.\r\n\r\n```js\r\nvar worker = ctx.socket('WORKER', {prefetch: 1});\r\n```\r\n\r\nFor instance, if you set `'prefetch'` to `1` on a **WORKER** socket,\r\nRabbitMQ will wait for you to call `#ack` for each message before\r\nsending another. On a **REP** socket, messages are acknowledged when\r\nthe reply is written (i.e., `#write` doubles as an `#ack`), so\r\n`'prefetch'` will limit how many replies the socket can have\r\noutstanding.\r\n\r\nIf you set it to `0`, RabbitMQ will forget any such\r\nconstraint and just send what it has, when it has it. The default\r\nvalue is `0`.\r\n\r\n##### `persistent`\r\n\r\nThe option `'persistent'` governs the lifetime of messages. Setting it\r\nto `true` means RabbitMQ will keep messages over restarts, by writing\r\nthem to disk. This is an option for all sockets, and crucially,\r\nsockets connected to the same address must agree on persistence\r\n(because they must all declare the server resources with the same\r\nproperties -- an unfortunate technical detail).\r\n\r\nIn the case of **REQ** and **REP** sockets, the requests may be\r\npersistent, but replies never are; in other words, `'persistent'`\r\napplies only to requests.\r\n\r\nIn the case of **SUB** and **PUB** sockets, `'persistent'` currently\r\nhas no effect, but they may nonetheless have the option set.\r\n\r\nSetting this option to `false` using `#setsockopt` means that the\r\nmessages following will not survive restarts, and any connections made\r\nwhile it is `false` will not persist messages. It may be set back\r\nto `true` of course, but this will not affect connections made in the\r\nmeantime.\r\n\r\nSee below for what `'persistent'` means in AMQP terms.\r\n\r\n## Using with servers\r\n\r\nA few modules have a socket-server-like abstraction; canonically, the\r\n`net` module, but also for example SockJS and Socket.IO. These can be\r\nadapted using something similar to the following.\r\n\r\n```js\r\nvar context = new require('rabbit.js').createContext('amqp://localhost');\r\nvar inServer = net.createServer(function(connection) {\r\n  var s = context.socket('PUB');\r\n  s.connect('incoming', function() {\r\n    connection.pipe(s);\r\n  });\r\n});\r\ninServer.listen(5000);\r\n```\r\n\r\nThis is a simplistic example: a bare TCP socket won't in general emit\r\ndata in chunks that are meaningful to applications, even if they are\r\nsent that way at the far end.\r\n\r\n## Examples\r\n\r\nEach subdirectory of `example` has code demonstrating using\r\nrabbit.js with other modules. Install the prerequisites for rabbit.js\r\nfirst:\r\n\r\n    rabbit.js$ npm install\r\n\r\nNow each example can be run with, e.g.,\r\n\r\n    rabbit.js$ cd example/sockjs\r\n    sockjs$ npm install && npm start\r\n\r\nAll of the examples assume there is a [RabbitMQ server\r\nrunning](http://rabbit.mq/download.html) locally. The SockJS and\r\nSocket.IO examples both start a website which you can visit at\r\n`http://localhost:8080`.\r\n\r\n## <a name=\"zeromq\"></a>Relation to ZeroMQ\r\n\r\nrabbit.js was inspired by the [RabbitMQ/ZeroMQ\r\nadapter](http://github.com/rabbitmq/rmq-0mq/) I developed with Martin\r\nSÃºstrik. The rationale for using RabbitMQ in a ZeroMQ-based network is\r\nlargely transferable to rabbit.js:\r\n\r\n * RabbitMQ introduces a degree of monitoring and transparency,\r\n   especially if one uses the web management app;\r\n * RabbitMQ can bridge to other protocols (notably AMQP and STOMP);\r\n * RabbitMQ provides reliable, persistent queues if desired\r\n\r\nwith some additional benefits:\r\n\r\n * since rabbit.js sockets implement the `Stream` interface, one\r\n   can easily pipe messages around\r\n * using RabbitMQ as a backend obviates some configuration management\r\n   -- just supply all instances the broker URL and you're good to go.\r\n * there's room in the API for more involved routing and other\r\n   behaviour since AMQP is, well, more complicated let's say.\r\n\r\nHere are some notable differences and similarities to ZeroMQ in\r\nrabbit.js's API and semantics.\r\n\r\nTo start, there's no distinction in rabbit.js between clients and\r\nservers (`connect` and `bind` in ZeroMQ, following the BSD socket\r\nAPI), since RabbitMQ is effectively acting as a relaying server for\r\neveryone to `connect` to. Relatedly, the argument supplied to\r\n`connect()` is abstract, in the sense that it's just a name rather\r\nthan a transport-layer address.\r\n\r\nRequest and Reply sockets have very similar semantics to those in\r\nZeroMQ. Repliers must respond to requests in the order that they come\r\nin, and respond exactly once to each request.\r\n\r\nThere are no DEALER or ROUTER sockets (a.k.a., XREQ and XREQ) in\r\nrabbit.js. In ZeroMQ these are implemented by prefixing messages with\r\na reverse path, which then requires encoding and thereby complication\r\nwhen relaying to other streams or protocols. Instead, rabbit.js notes\r\nthe reverse path as messages are relayed to a REP socket, and\r\nreapplies it when the response appears (giving rise to the ordering\r\nrequirement on replies).\r\n\r\nThere is no WORKER socket in ZeroMQ; the advice generally given is to\r\nuse a REQ/REP pair and convey acknowledgments back to the requester\r\n(which is to retry in the case of failure or more likely,\r\ntimeout). Since rabbit.js has RabbitMQ as a reliable intermediary,\r\nthis can be cut short, with acknowledgments and retry handled by\r\nRabbitMQ.\r\n\r\n## Relation to AMQP and STOMP\r\n\r\nrabbit.js makes some simplifying assumptions that must be kept in mind\r\nwhen integrating with other protocols that RabbitMQ supports.\r\n\r\nPUB and SUB sockets declare exchanges named for the argument given to\r\n`#connect` and with the type given by the `'routing'` option. If a\r\n`topic` argument is given to `#connect`, it's used as the routing key\r\npattern, otherwise `''` is used.\r\n\r\nTo send to SUB sockets or receive from PUB sockets, publish or bind\r\n(or subscribe in the case of STOMP) to the exchange with the same name\r\nas given to `#connect`.\r\n\r\nPUSH, PULL, REQ and REP sockets use non-exclusive queues named for the\r\nargument given to `connect`. If you are replying via AMQP or STOMP, be\r\nsure to follow the convention of sending the response to the queue\r\ngiven in the `'replyTo'` property of the request message, and copying\r\nthe `'correlationId'` property from the request in the reply. If you\r\nare requesting via AMQP or STOMP, at least supply a `replyTo`, and\r\nconsider supplying a `correlationId`.\r\n\r\nThe option `'persistent'` relates both to the `durable` property of\r\nqueues and to the `deliveryMode` property given to messages. If a\r\nsocket is `persistent`, it will declare queues as `durable`, and send\r\nmessages with `deliveryMode` of `2`. The exceptions are SUB sockets,\r\nwhich don't declare their subscription queue as durable, although PUB\r\nsockets are allowed to publish persistent (`deliveryMode=2`) messages;\r\nand REQ sockets, which **do** declare the request queue (that they\r\nsend to) as durable, but not their own reply queue.\r\n\r\n[amqplib]: https://github.com/squaremo/amqp.node/\r\n[node-amqp]: https://github.com/postwait/node-amqp/\r\n[nodejs-stream]: http://nodejs.org/docs/v0.10.21/api/stream.html\r\n[ordering-example]: https://github.com/squaremo/rabbit.js/tree/master/example/ordering\r\n[rabbitmq-topic-tute]: http://www.rabbitmq.com/tutorials/tutorial-five-python.html\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}